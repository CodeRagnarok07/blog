¿Qué es una excepción en JavaScript?;Una excepción en JavaScript es un evento que interrumpe el flujo normal de ejecución de un programa. Las excepciones pueden ser lanzadas por el motor de JavaScript cuando ocurre un error o explícitamente por el código.;Las excepciones son útiles para manejar errores y condiciones anormales de manera controlada.;try { throw new Error('Something went wrong') } catch (e) { console.log(e.message) };
¿Cómo se utiliza la declaración try...catch en JavaScript?;La declaración try...catch en JavaScript se utiliza para manejar excepciones. El bloque try contiene el código que puede lanzar una excepción, y el bloque catch contiene el código que maneja la excepción.;El bloque catch se ejecuta si se lanza una excepción en el bloque try.;try { let result = riskyOperation() } catch (error) { console.error('An error occurred:', error) };
¿Qué es el bloque finally en una estructura try...catch?;El bloque finally es una parte opcional de la estructura try...catch que se ejecuta siempre, independientemente de si se lanzó una excepción o no. Se utiliza para realizar limpieza o liberar recursos.;El bloque finally se ejecuta después de los bloques try y catch.;try { let data = fetchData() } catch (e) { console.error('Fetch error:', e) } finally { console.log('Cleanup actions here') };
¿Cómo se lanza una excepción en JavaScript?;Se puede lanzar una excepción en JavaScript usando la palabra clave throw seguida de una expresión que representa el error. Esta expresión puede ser un objeto Error, una cadena, un número, etc.;Lanzar excepciones permite manejar errores de manera controlada en diferentes partes del código.;throw new Error('This is a custom error') throw 'This is a string error' throw 404;
¿Qué tipos de objetos de error existen en JavaScript?;JavaScript tiene varios tipos de objetos de error nativos, incluyendo Error, SyntaxError, TypeError, RangeError, ReferenceError, y EvalError. Cada tipo representa una categoría específica de error.;Los objetos de error pueden ser personalizados creando subclases de Error.;try { undefinedFunction() } catch (e) { if (e instanceof ReferenceError) { console.error('ReferenceError caught:', e) } }
¿Cómo se pueden crear errores personalizados en JavaScript?;Se pueden crear errores personalizados extendiendo la clase Error. Esto permite definir errores específicos para la aplicación y proporcionar mensajes de error más detallados.;Los errores personalizados pueden incluir propiedades adicionales para más contexto.;class CustomError extends Error { constructor(message) { super(message) this.name = 'CustomError' } } throw new CustomError('Something specific went wrong');
¿Qué es el objeto Error en JavaScript?;El objeto Error en JavaScript representa un error y contiene información sobre el error, como su mensaje y el stack trace. Se utiliza para manejar y lanzar excepciones.;El objeto Error puede ser extendido para crear errores personalizados.;try { throw new Error('An error occurred') } catch (e) { console.error(e.name + ': ' + e.message) };
¿Cómo se maneja un error sin detener la ejecución del programa?;Para manejar un error sin detener la ejecución del programa, se utiliza la declaración try...catch. Al atrapar el error, el código puede continuar ejecutándose después del bloque catch.;Es útil para mantener la aplicación funcionando y proporcionar retroalimentación al usuario.;try { let result = riskyOperation() } catch (e) { console.error('Error handled:', e) } console.log('Execution continues');
¿Qué es un TypeError en JavaScript?;Un TypeError en JavaScript es un error que ocurre cuando un valor no es del tipo esperado. Por ejemplo, intentar acceder a una propiedad de undefined o llamar a una variable que no es una función.;TypeError es una subclase del objeto Error.;try { let obj console.log(obj.property) } catch (e) { if (e instanceof TypeError) { console.error('TypeError caught:', e) } };
¿Cuál es la diferencia entre ReferenceError y SyntaxError?;ReferenceError ocurre cuando se hace referencia a una variable que no está definida. SyntaxError ocurre cuando hay un error en la sintaxis del código, como un paréntesis mal colocado.;Ambos son tipos de errores que se lanzan automáticamente por el motor de JavaScript.;try { console.log(undefinedVar) } catch (e) { if (e instanceof ReferenceError) { console.error('ReferenceError caught:', e) } } try { eval('var a = ') } catch (e) { if (e instanceof SyntaxError) { console.error('SyntaxError caught:', e) } };
¿Cómo se puede utilizar un catch condicional en JavaScript?;Un catch condicional maneja diferentes tipos de errores de manera específica usando múltiples bloques catch o condiciones dentro de un solo bloque catch.;Esto permite una respuesta más precisa y apropiada a diferentes errores.;try { // Código que puede lanzar diferentes errores } catch (e) { if (e instanceof TypeError) { console.error('TypeError caught:', e) } else if (e instanceof ReferenceError) { console.error('ReferenceError caught:', e) } else { console.error('General error caught:', e) } };
¿Por qué es importante manejar excepciones en aplicaciones JavaScript?;Manejar excepciones es importante para mantener la estabilidad y usabilidad de una aplicación. Permite capturar errores, proporcionar mensajes de error útiles y evitar que la aplicación se bloquee.;Un manejo adecuado de excepciones mejora la experiencia del usuario y facilita la depuración.;try { let data = riskyFunction() } catch (e) { console.error('Error:', e.message) alert('An error occurred. Please try again later.') };
¿Cómo se pueden encadenar múltiples operaciones de riesgo con manejo de excepciones?;Para encadenar múltiples operaciones de riesgo, se pueden anidar bloques try...catch o usar un solo bloque try con múltiples llamadas de función dentro.;Esto permite manejar errores en secuencias de operaciones de manera controlada.;try { let result1 = riskyOperation1() let result2 = riskyOperation2(result1) let result3 = riskyOperation3(result2) } catch (e) { console.error('Error in one of the operations:', e) };
¿Qué es un RangeError en JavaScript?;Un RangeError en JavaScript ocurre cuando un valor no está dentro del conjunto o rango permitido. Por ejemplo, cuando se pasa un número fuera del rango permitido a una función.;RangeError es una subclase del objeto Error.;try { let num = new Array(-1) } catch (e) { if (e instanceof RangeError) { console.error('RangeError caught:', e) } };
¿Cómo se puede re-lanzar una excepción en un bloque catch?;Para re-lanzar una excepción en un bloque catch, se utiliza la palabra clave throw dentro del bloque catch. Esto permite capturar la excepción, realizar alguna acción y luego volver a lanzarla para que sea manejada en un nivel superior.;Re-lanzar excepciones es útil cuando se necesita realizar alguna limpieza o logging antes de dejar que el error se propague.;try { let result = riskyOperation() } catch (e) { console.error('Error caught:', e) throw e };
¿Qué es un EvalError en JavaScript?;EvalError es un tipo de error que se lanza cuando hay un problema con la función global eval(). Sin embargo, en las versiones modernas de JavaScript, este error rara vez se utiliza.;EvalError es una subclase del objeto Error y se mantiene por razones de compatibilidad hacia atrás.;try { eval('invalid code') } catch (e) { if (e instanceof EvalError) { console.error('EvalError caught:', e) } };
¿Cómo se puede utilizar el operador opcional de encadenamiento (?.) para evitar excepciones?;El operador opcional de encadenamiento (?.) se utiliza para acceder a propiedades de objetos que pueden no existir sin lanzar una excepción. Si una propiedad no existe, devuelve undefined en lugar de lanzar un error.;Este operador es útil para manejar objetos anidados o datos opcionales de manera segura.;let user = {} console.log(user?.profile?.email) // undefined;
¿Cómo se maneja una excepción específica utilizando instanceof?;Para manejar una excepción específica, se utiliza el operador instanceof dentro del bloque catch para verificar el tipo de error. Esto permite ejecutar código de manejo de errores específico para diferentes tipos de excepciones.;Es una práctica común para proporcionar una respuesta más precisa a diferentes errores.;try { let data = riskyFunction() } catch (e) { if (e instanceof TypeError) { console.error('TypeError:', e) } else if (e instanceof RangeError) { console.error('RangeError:', e) } else { console.error('Other error:', e) } };
¿Qué es un promise rejection y cómo se maneja?;Un promise rejection ocurre cuando una promesa se rechaza debido a un error o condición insatisfecha. Se maneja utilizando el método .catch() en la promesa para capturar y manejar el error.;Las promesas rechazadas pueden encadenarse con otras operaciones asincrónicas.;let promise = new Promise((resolve, reject) => { reject('An error occurred') }) promise.catch(error => { console.error('Promise rejected:', error) });
¿Cómo se puede manejar múltiples errores en una función async/await?;En una función async/await, se pueden manejar múltiples errores utilizando un bloque try...catch alrededor de las llamadas await. Esto captura cualquier excepción lanzada por las promesas.;Es una práctica recomendada para mantener el código asincrónico limpio y manejable.;async function fetchData() { try { let response = await fetch('https://api.example.com/data') let data = await response.json() return data } catch (error) { console.error('Error fetching data:', error) throw error } };
¿Qué es un AggregateError en JavaScript?;AggregateError es un tipo de error que representa un grupo de errores. Se utiliza con la API Promise.any() para manejar múltiples errores de una operación asíncrona.;AggregateError es una subclase del objeto Error y contiene una propiedad errors que es un array de los errores individuales.;try { await Promise.any([ promise1, promise2 ]) } catch (e) { if (e instanceof AggregateError) { console.error('Multiple errors:', e.errors) } };
¿Cómo se captura y maneja una excepción en un código asincrónico con promesas?;Para capturar y manejar una excepción en un código asincrónico con promesas, se utiliza el método .catch() después de la promesa. Esto permite manejar cualquier error que ocurra durante la ejecución de la promesa.;El método .catch() se encadena al final de la cadena de promesas.;fetch('https://api.example.com/data') .then(response => response.json()) .catch(error => { console.error('Error fetching data:', error) });
¿Cómo funciona el objeto Proxy en el manejo de excepciones?;El objeto Proxy puede ser utilizado para interceptar y redefinir operaciones en un objeto, incluyendo el acceso a propiedades y la invocación de métodos. Puede ser utilizado para manejar excepciones de manera personalizada.;El objeto Proxy permite crear manejadores para operaciones como get, set, apply, etc.;let target = {} let handler = { get: function(target, property) { if (property in target) { return target[property] } else { throw new Error(`Property ${property} does not exist`) } } } let proxy = new Proxy(target, handler) try { console.log(proxy.nonExistentProperty) } catch (e) { console.error(e.message) };
¿Por qué es importante limpiar recursos en el bloque finally?;Es importante limpiar recursos en el bloque finally porque este bloque siempre se ejecuta independientemente de si se lanzó una excepción o no. Esto asegura que los recursos, como archivos abiertos o conexiones de red, se liberen correctamente.;El uso del bloque finally previene fugas de recursos y asegura un comportamiento consistente.;let fileHandle try { fileHandle = openFile('somefile.txt') // Operaciones con el archivo } catch (e) { console.error('File error:', e) } finally { if (fileHandle) { closeFile(fileHandle) } };
¿Cómo se pueden manejar excepciones globales en una aplicación JavaScript?;Las excepciones globales se pueden manejar utilizando el evento window.onerror en el navegador. Este evento captura errores no manejados y permite registrar o realizar acciones específicas.;En Node.js, se utiliza process.on('uncaughtException') para manejar excepciones no capturadas.;window.onerror = function(message, source, lineno, colno, error) { console.error('Global error:', message, 'at', source, lineno + ':' + colno) return true };
¿Qué es la delegación de manejo de errores y cómo se implementa?;La delegación de manejo de errores implica atrapar excepciones en un nivel superior de la aplicación y delegar el manejo de esas excepciones a funciones o módulos específicos. Esto centraliza el manejo de errores y mejora la mantenibilidad.;Se puede implementar utilizando funciones que atrapan y reenvían errores a manejadores específicos.;function handleError(e) { console.error('Error handled:', e) } try { riskyOperation() } catch (e) { handleError(e) };
¿Cómo se puede utilizar el patrón de circuito cortado (circuit breaker) para manejar excepciones?;El patrón de circuito cortado (circuit breaker) se utiliza para prevenir que una operación fallida continúe ejecutándose, permitiendo que el sistema se recupere antes de intentar la operación de nuevo. Es útil para manejar fallos repetidos en operaciones críticas.;Este patrón se puede implementar utilizando contadores y temporizadores para controlar los intentos de operación.;class CircuitBreaker { constructor() { this.failures = 0 this.state = 'CLOSED' } call(func) { if (this.state === 'OPEN') { throw new Error('Circuit is open') } try { func() this.failures = 0 } catch (e) { this.failures++ if (this.failures >= 3) { this.state = 'OPEN' setTimeout(() => { this.state = 'CLOSED' }, 10000) } throw e } } } let breaker = new CircuitBreaker() try { breaker.call(riskyOperation) } catch (e) { console.error('Operation failed:', e) };
¿Qué es un fallo silenciado y cómo se puede evitar?;Un fallo silenciado ocurre cuando una excepción es capturada pero no se maneja adecuadamente, lo que puede llevar a errores difíciles de detectar. Para evitar fallos silenciados, siempre se debe proporcionar algún manejo útil o registro de errores.;Es una buena práctica asegurar que todas las excepciones capturadas se registren o se manejen de manera informativa.;try { riskyOperation() } catch (e) { console.error('Error:', e) // Manejo o registro adecuado };
